var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"Order = [:type]","category":"section"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"Order = [:macro, :function]","category":"section"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#PropDicts.MissingProperty","page":"API","title":"PropDicts.MissingProperty","text":"struct MissingProperty\n\nAn instance MissingProperty(parent, key::Symbol) represents the fact the key is missing in parent.\n\nInstances of MissingProperty support setindex! and setproperty!, this will create the key in parent as a PropDict.\n\n\n\n\n\n","category":"type"},{"location":"api/#PropDicts.PropDict","page":"API","title":"PropDicts.PropDict","text":"PropDict <: AbstractDict{Union{Symbol,Int},Any}\n\nPropDicts is a dictionary for that supports\n\nConstructors:\n\nPropDict(dict::AbstractDict)\n\nPropDict(key1 => value, key2 => value2, ...)\n\nDuring construction, keys are automatically converted to Symbols and Ints, values that are dicts are converted to PropDicts.\n\nPropDict support deep merging:\n\nx = PropDict(:a => PropDict(:b => 7, :c => 5, :d => 2), :e => \"foo\")\ny = PropDict(:a => PropDict(:c => 42, :d => nothing), :f => \"bar\")\n\nz = merge(x, y)\n@assert z == PropDict(\n    :a => PropDict(:b=>7, :d => nothing, :c => 42),\n    :e => \"foo\", :f => \"bar\"\n)\n\nPropDicts.trim_null!(z)\n@assert z == PropDict(\n    :a => PropDict(:b=>7, :c => 42),\n    :e => \"foo\", :f => \"bar\"\n)\n\nAcessing non-existing properties will return instances of PropDicts.MissingProperty). When setting the value of missing properties, parent PropDicts are created automatically:\n\nz.foo.bar isa PropDicts.MissingProperty\nz.foo.bar = 42\nz.foo.bar == 42\n\nPropDicts can be read/written to/from JSON and YAML files using readprops and writeprops. Note that the Julia packages JSON resp. YAML need to be loaded first.\n\nnote: Note\nLike with Base.Dict, mutating a PropDict is not thread safe.\n\n\n\n\n\n","category":"type"},{"location":"api/#PropDicts.readprops","page":"API","title":"PropDicts.readprops","text":"readprops(filename::AbstractString; subst_pathvar::Bool = true, subst_env::Bool = true, trim_null::Bool = true)\nreadprops(filenames::Vector{<:AbstractString}; ...)\n\nRead a PropDict from a single or multiple files.\n\nreadprops supports JSON and YAML files. Note that the Julia packages JSON resp. YAML need to be loaded first.\n\nIf multiple files are given, they are merged into a single PropDict using merge.\n\nsubst_pathvar controls whether $_ should be substituted with the directory path of the/each file within string values (but not field names).\n\nsubst_env controls whether $ENVVAR should be substituted with the value of the each environment variable ENVVAR within string values (but not field names).\n\ntrim_null controls whether JSON/YAML null values should be removed entirely.\n\n\n\n\n\n","category":"function"},{"location":"api/#PropDicts.trim_null!","page":"API","title":"PropDicts.trim_null!","text":"trim_null!(d::AbstractDict; recursive::Bool = true)\n\nRemove values equal to nothing from d.\n\nOperates recursively on values in d if recursive == true.\n\n\n\n\n\n","category":"function"},{"location":"api/#PropDicts.writeprops","page":"API","title":"PropDicts.writeprops","text":"writeprops(io::IO, p::PropDict; multiline::Bool = true, indent::Int = -1)\nwriteprops(filename, p::PropDict; format = :JSON, multiline::Bool = true, indent::Int = -1)\n\nWrite PropDict p to JSON file filename.\n\nwriteprops supports JSON and YAML files. Note that the Julia packages JSON resp. YAML need to be loaded first.\n\nmultiline = false is not supported for YAML files.\n\nUse indent = -1 for default indentation in multiline mode.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"section"},{"location":"#PropDicts.jl","page":"Home","title":"PropDicts.jl","text":"PropDicts implements dictionaries that handle hierarchical property/value data.\n\nPropDict is a special kind of AbstractDict that supports deep merging. A typicial use case is cascading-configuration: A basic configuration can be modified by additional configuration PropDicts that only replace, amend or remove specific parts of it.\n\nIn addition, there is support for variable substitution, to make it possible to refer to environment variables and application-specific variables in configuration data.\n\nReading/writing from/to JSON and YAML is supported as well.","category":"section"}]
}
